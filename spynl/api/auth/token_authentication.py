"""
This module defines functions for generating, validating and decrypting tokens
for authentication.
"""
import os
import uuid
from datetime import datetime

import boto3
import bson
import requests
from botocore.exceptions import BotoCoreError, ClientError
from pyramid.authentication import CallbackAuthenticationPolicy
from pyramid.interfaces import IAuthenticationPolicy
from zope.interface import implementer

from spynl.locale import SpynlTranslationString as _

from spynl.main.exceptions import SpynlException
from spynl.main.utils import get_settings

from spynl.api.auth.authorization import Principals
from spynl.api.hr.exceptions import TokenError


def legacy_token_request(token, request, revoke=False, description=None):
    # skip this step in e2e tests.
    if os.environ.get('SPYNL_ENVIRONMENT') == 'e2e':
        return

    # This admin token is a special token especially for
    # management of FoxPro webshops. This is not the typical token
    # used in other FoxPro Legacy API requests.
    admin_token = '1660-8920-F99A-11E0-BE50-0800-200C-9A66'
    fp_url = get_settings().get('spynl.pipe.fp_web_url')
    if not fp_url:
        raise SpynlException(_('no-foxpro-url'))

    functions = {True: 'revoketoken', False: 'createtoken'}

    payload = [
        ('function', functions[revoke]),
        ('token', admin_token),
        ('sid', token),
        ('tenantid', request.requested_tenant_id),
    ]
    if description:
        payload.append(('description', description))

    query_string = '?' + '&'.join(['%s=%s' % (k, v) for k, v in payload])
    response = requests.get(fp_url + query_string + '&format=json')
    try:
        response.raise_for_status()
    except requests.exceptions.HTTPError as e:
        token_err = TokenError(
            _('default-token-error'), developer_message='Problem with AWS request'
        )
        raise token_err from e


def _export_into_usage_plan(usage_plan, name, description, key):
    """Export an api key into an AWS gateway usageplan."""
    client = boto3.client('apigateway')
    csv = (
        'Name,Key,Description,Enabled,UsageplanIds\n'
        '{name},{key},{description},TRUE,{usageplanid}\n'
    ).format(name=name, description=description, key=key, usageplanid=usage_plan)
    try:
        response = client.import_api_keys(
            body=csv.encode('u8'), format='csv', failOnWarnings=True
        )
    except (BotoCoreError, ClientError) as e:
        token_err = TokenError(
            _('default-token-error'), developer_message='Problem with AWS request'
        )
        raise token_err from e

    return response['ids'][0]


def _disable_in_usage_plan(key):
    """Disable an api key in an AWS gateway usageplan."""
    client = boto3.client('apigateway')
    try:
        response = client.update_api_key(
            apiKey=key,
            patchOperations=[{'op': 'replace', 'path': '/enabled', 'value': 'false'}],
        )
    except (BotoCoreError, ClientError) as e:
        token_err = TokenError(
            _('default-token-error'), developer_message='Problem with AWS request'
        )
        raise token_err from e

    return response['enabled'] is False


def revoke(db, token):
    token = uuid.UUID(str(token))
    token = db.tokens.find_one({'$or': [{'_id': token}, {'token': token}]})
    if token is None:
        raise ValueError

    if 'aws_id' in token:
        if _disable_in_usage_plan(token['aws_id']) is False:
            raise TokenError(
                _('default-token-error'),
                developer_message=(
                    'Could not disable token in aws usage plan %s' % token['usage_plan']
                ),
            )

    db.tokens.update_one({'_id': token['_id']}, {'$set': {'revoked': True}})
    return db.tokens.get(token['_id'])


def generate(db, user_id, tenant_id, usage_plan=None, payload=None, token_=None):
    """
    Generate a urlsafe token with a payload.
    """

    token = dict(
        _id=uuid.uuid4(),
        token=token_ or uuid.uuid4(),
        user_id=user_id,
        tenant_id=tenant_id,
        revoked=False,
    )
    if payload:
        token.update(payload)

    if usage_plan:
        token['usage_plan'] = usage_plan
        name = '%s-%s' % (tenant_id, user_id)
        description = 'Token for tenant %s Generated by %s on %s.' % (
            tenant_id,
            user_id,
            datetime.utcnow().strftime('%c'),
        )
        aws_id = _export_into_usage_plan(
            token['usage_plan'], name, description, str(token['token'])
        )
        if aws_id:
            token.update(aws_id=aws_id)
        else:
            raise TokenError(
                _('default-token-error'),
                developer_message=(
                    'Could not export token to aws usage plan %s' % token['usage_plan']
                ),
            )

    result = db.tokens.insert_one(token)
    return db.tokens.get(result.inserted_id)


@implementer(IAuthenticationPolicy)
class TokenAuthAuthenticationPolicy(CallbackAuthenticationPolicy):
    """
    Token based authentication policy.

    It is very much based on the BasicAuthenticationPolicy that pyramid
    already provides.
    """

    def unauthenticated_userid(self, request):
        """Return the userid without extra validation."""
        if request.token_payload:
            userid = request.token_payload['user_id']
            try:
                userid = bson.ObjectId(userid)
            except (bson.errors.InvalidId, TypeError):
                pass
            return userid

    def authenticated_userid(self, request):
        """Return the userid without extra validation."""
        if request.token_payload:
            userid = request.token_payload['user_id']
            try:
                userid = bson.ObjectId(userid)
            except (bson.errors.InvalidId, TypeError):
                pass
            return userid

    def callback(self, _, request):
        """Return a list of groups and principals for the token."""

        if request.token_payload:
            result = [
                'role:%s' % role for role in request.token_payload.get('roles', [])
            ]

            # tokens don't have an explicit relation to tenants, they have
            # tenant information though which is checked after.
            result.append(Principals.NoNeedToBelongToTenant)

            return result

    def remember(self, *args, **kwargs):
        """No-op"""
        return []

    def forget(self, *args, **kwargs):
        """No-op"""
        return []
